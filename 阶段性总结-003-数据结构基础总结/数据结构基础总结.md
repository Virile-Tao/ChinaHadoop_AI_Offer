## 复杂度分析（上）
### 1.大O的出场
所有代码的执行时间T(n)与每行代码的执行次数n成正比。T(n)=O(f(n))，O()表示执行时间T(n)与f(n)成正比，大O的时间复杂度实际上并不具体表示代码的真正执行时间，而是代表代码执行时间随着数据规模增长的变化趋势，因此也叫渐进时间复杂度，简称时间复杂度
### 2.时间复杂度分析
1.只关注循环次数执行最多的一段代码  
2.加法法则  
3.乘法法则
### 3.空间复杂度分析
时间复杂度全称为渐进时间复杂度，是代码执行时间随着数据规模增长的变化趋势，相应的，空间复杂度全称渐进空间复杂度，是算法存储空间随着数据规模增长的变化趋势
## 复杂度分析（下）
### 1.最好最坏情况时间复杂度
### 2.平均情况时间复杂度
也是加权平均值，对应的时间复杂度是加权平均时间复杂度
### 3.均摊时间复杂度
特殊的平均时间复杂度
## 数组
### 1.随机访问
数组是一种线性表数据结构，用一组连续的内存空间，存储一组相同类型的数据  
关于线性表，数据排成一条线一样的结构，每个线性表上的数据最多只有前和后两个方向。除了数组，其他如队列，栈、链表都是线性表结构
### 2.连续的内存空间和相同类型的数据
数组的一个杀手锏：随机访问。但是有利有弊，数组的插入和删除操作会变得非常低效。因为要保证连续性，就需要做大量的数据搬移工作。
## 链表
### 1.链表结构
跟数组相反，链表并不需要连续的内存空间，它通过“指针”将一组零散的内存块串联起来，从而进行数据存储的数据结构  
链表的每个内存块被称为节点Node。为了将所有节点都串起来，节点除了存储数据外，还需记录下一个节点的地址，也就是后继指针next
### 2.链表、数组性能大比拼
内存充足，推荐链表；堆内存的使用苛刻，使用数组
### 3.链表实现LRU算法
维护一个有序单链表，越靠尾部的节点是越早之前访问的，当有一个新数据被访问时，我们从链表头部开始顺序遍历链表
### 4.指针或引用的含义
### 5.警惕指针丢失和内存泄漏
### 6.利用哨兵简化实现难度
使用带头节点的链表（哑节点）
### 7.留意边界条件处理
## 栈
这种先进后出，后进先出，就是典型的栈结构，从操作特性来说，栈是一种操作受限的线性表，只允许在一端进行插入和删除数据
### 1.实现一个栈
```python
# 基于列表实现的顺序栈
class Stack(object):
    def __init__(self, n):
        self.stack = [None] * n
        self.n = n # 栈的大小
        self.count = 0 # 栈中元素个数
        
    def push(self, value):
        if self.n == self.count:
            return False
        self.stack[count] = value
        self.count += 1
        return True
    
    def pop(self, value):
        if self.count == 0:
            return None
        temp = self.stack[count-1]
        count -= 1
        return temp
```
### 2.支持动态扩容的顺序栈
### 3.栈在函数调用中的应用
### 4.栈在表达式求值中的应用
### 5.如何实现浏览器的前进、后退功能
### 6.内存中的堆栈和数据结构中的堆栈
> * 内存中的堆栈和数据结构中的堆栈不是一个概念，可以说内存中的堆栈是真实存在的物理区，数据结构中的堆栈是抽象的数据结构。  
> * 内存空间在逻辑上划分为三个部分：代码区、静态数据区和动态数据区，动态数据区又分为堆区和栈区。  
> * 代码区：存储方法体的二进制代码。高级调度（作业调度）、中级调度（内存调度）、低级调动（进程调度）控制底阿妈去执行代码的切换。  
> * 静态数据区：存储全局变量、静态常量、常量、常量包括final修饰的常量和String常量，系统自动分配和回收。
> * 栈区：存储运行方法的形参、局部变量、返回值，由系统自动分配和回收。
> * 堆区：new一个对象的引用或者地址存储在栈区，指向该对象存储在堆区的真实数据。
## 队列
先进先出，这就是典型的队列。  
栈只支持两个基本操作，入栈和出栈。队列跟栈非常相似，支持的操作也很有限，入队和出队。所以，队列跟栈一样，也是一种操作受限的线性表数据结构。
### 1.顺序队列和链式队列（实现队列）
```python
# 用列表实现队列
class Dueue(object):
    def __init__(self, n):
        self.queue = [None] * n
        self.n = n
        self.head = 0
        self.tail = 0
        
    def enqueue(self, value):
        if self.tail == n:
            return False
        self.queue[taile] = value
        self.tail += 1
        return True
    
    def dequeue(self):
        if self.head == self.tail:
            return None
        temp = self.queue[head]
        self.head += 1
        return temp
```
### 2.阻塞队列和并发队列
> * 阻塞队列其实就是在队列基础上增加了阻塞操作，简单来说，就是在队列为空的时候，从队列头部取数据会受到阻塞，因为此时还没有数据。如果队列已经满了，那么插入数据的操作就会被阻塞，知道队列中有空闲才会插入数据，然后返回。
> * 可以使用阻塞队列实现一个“生产者-消费者”模型，可以有效地协调生产和消费的速度。当“生产者”生产的数据的速度过快，“消费者”来不及消费时，存储数据的队列很快就会满了。这个时候，生产者就会阻塞等待，知道“消费者”消费了数据，“生产者”才会被唤醒继续“生产”。不仅如此，基于阻塞队列，可以通过协调“生产者”和“消费者”的个数，来提高数据的处理效率，我们可以多配制几个“消费者”，应对一个“生产者”。
> * 线程安全的队列我们叫做并发队列。最简单直接的方式是在enqueue()、dequeue()方法上加锁，但是锁粒度大并发度会降低，同一时刻仅允许一个存或者取操作。
